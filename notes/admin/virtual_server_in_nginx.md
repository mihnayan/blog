# Создание виртуального сервера в nginx #


## Введение ##

Эта заметка является далеко не исчерпывающей по своему содержанию, более того, некоторые моменты сознательно опущены для простоты понимания. Заметка появилась всего-лишь по просьбе коллеги написать краткую простую инструкцию о том, как добавить виртуальный сервер в nginx для разных доменных имен.

Более полная информация, как обычно, содержится в разделе ["Веб-сервер"](http://nginx.com/resources/admin-guide/web-server) [руководства администратора nginx](http://nginx.com/resources/admin-guide/).

*Примечание. В заметке речь идет от веб-сервере nginx, установленном на ОС CentOS 6.5*


## Файл конфигурации ##

Виртуальный сервер в nginx описывается в файле конфигурации, размещение которого зависит от операционной системы. По умолчанию файл конфигурации называется `nginx.conf` и может лежать в одном из каталогов:

	/usr/local/nginx/conf
	/etc/nginx
	/usr/local/etc/nginx

В данном случае это каталог `/etc/nginx`.

Файл конфигурации состоит из директив, которые могут быть как простыми - в виде одной строки, так и блочными - выделяемыми фигурными скобками `{}`, и содержащими в себе простые.

Каждая простая директива **должна оканчиваться точкой с запятой `;`** (частая ошибка - не указывается точка с запятой после редактирования файла конфигурации, что приводит к ошибке запуска веб-сервера).

Блоковая директива, содержащая в себе другие директивы, также называется **контекстом**. Так весь файл конфигурации - это основной контекст (main context). Так же контекстом являются другие блоковые директивы: `events`, `http`, `server`, `location`. При этом директивы `events` и `http` размещаются в основном контексте, директива `server` - в контексте `http`, и директива `location` - в контексте `server`.


## Описание виртуального сервера ##

### Создание отдельного файла конфигурации ###

Сервер в конфигурационном файле nginx описывается директивой `server`, которая располагается в контексте `http`:

	http {
		server {
			...
		}
	}

В файле конфигурации, созданном по умолчанию, некоторые настройки внутри контекста `http` вынесены в отдельные файлы также с расширением `.conf`, и размещенные в подкаталоге `conf.d`. Подключаются эти файлы директивой `include`:

	http {
		...
		include /etc/nginx/conf.d/*.conf;
		...
	}

Этим обстоятельством можно воспользоваться для того, чтобы не править лишний раз основной файл конфигурации, а прописать настройки нового виртуального сервера в отдельном файле. Если этот файл будет размещен в подкаталоге `conf.d` и иметь расширение `.conf`, то он автоматически будет подключатся вместе со всеми остальными ему подобными файлами.

Можно создать дополнительный файл конфигурации в другом месте и подключать его отдельной директивой `include`. Тогда, в случае необходимости, его легко будет отключить просто закомментировав строку подключения (для комментариев в настойках nginx используется символ `#`).

Еще одним преимуществом отдельного файла для описания виртуального сервера будет являться "чистота" файла. То есть отсутствие лишних директив и акцентирование только на описании непосредственно сервера.

Так как директива `include` уже размещена в контексте `http`, то в подключаемом файле конфигурации можно начать сразу с блочной директивы `server`:

	server {
		...
	}


### Некоторые директивы для описания сервера ###


Описание виртуального сервера в файле конфигурации может иметь много особенностей, зависящих от контента, используемого на веб-вервере, размещения этого контента, от технологических моментов работы веб-приложения (например, используемый язык программирования на стороне сервера). Здесь рассматриваются самые общие вопросы конфигурации. За более подробной информацией можно обратиться к [документации по директиве `server`](http://nginx.org/en/docs/http/ngx_http_core_module.html#server). 

При описании нового виртуального сервера следует исходить из того, что в конфигурации nginx уже прописан сервер по умолчанию примерно следующим образом (закомментированные директивы опущены):

	server {
    	listen       80;
	    server_name  localhost;

    	location / {
    	    root   /usr/share/nginx/html;
    	    index  index.html index.htm;
    	}

    	# redirect server error pages to the static page /50x.html
    	#
    	error_page   500 502 503 504  /50x.html;
    	location = /50x.html {
    	    root   /usr/share/nginx/html;
    	}
	}

#### Директивы server_name и listen ####


	server {
		listen 80;
		server_name www.example.com www.example.org;
		...
	}

Здесь: 

* `server_name` - имя сервера (возможно так же указание нескольких серверов через пробел);
* `listen` - прослушиваемый порт (может также указываться так же, как *ip-адрес:порт*).

Можно сказать, что эта связка - `server_name` и `listen` - является ключевой при определении конфигурации сервера. Другими словами, если на прослушиваемый порт `listen` поступает http-запрос, в котором заголовок `host` имеет *одно из значений* равное `server_name`, то применяется именно эта конфигурация.

При описании дополнительных виртуальных серверов можно и опустить директиву `listen`. Тогда прослушиваться будет порт по умолчанию. В свою очередь, порт по умолчанию - это может быть порт, указанный в какой-нибудь конфигурации с параметром `default_server`, как, например:

	server {
		listen		80 default_server;
		...
	}

Если же параметр `default_server` ни где не указан, то портом по умолчанию считается порт, указанный в конфигурации для первого сервера. Дополнительно можно акцентировать, что *параметр `default_server` относится только к прослушиваемому порту, но не к имени сервера*. Так как при установке nginx создается файл конфигурации по умолчанию, в котором уже прописан сервер для порта `80`, то можно считать его портом по умолчанию. 

Таким образом, если порт для дополнительного сервера не меняется, то можно начать конфигурацию с директивы `server_name`.


#### Директива root ####


	server {
		server_name www.example.com www.example.org;
		root   /usr/share/nginx/example;
		...
	}

`root` определяет корневой каталог файловой системы сервера для заданного виртуального сервера.  *Надо помнить, что выход за корневой каталог не возможен.* То есть, например, указание `../1.gif` не вернет ожидаемого файла, если этот относительный путь указан относительно корневого каталога.


#### Директива location ####

Пример:

	server {
		server_name www.example.com www.example.org;
		root   /usr/share/nginx/example;

		location / {
			...
		}
		...
	}

Директива `location` - блочная, задает конфигурацию сервера в зависимости от запрошенного URI, проверяя  его на соответствие заданному в директиве выражению. Это выражение может определяться либо в виде префиксной подстроки, либо в виде регулярного выражения, либо может указываться полное соответствие при помощи модификатора `=`. Внутри директивы `server` может быть более одной директивы `location`.

При поиске соответствия URI сначала проверяются директивы `location`, значение которых задано в виде префикса. Конфигурация `location` с самой длинной совпавшей строкой запоминается. После этого идет сравнение со значениям в виде регулярного выражения в порядке, указанном в конфигурационном файле. При первом же совпадении URI с регулярным выражением поиск останавливается и конфигурация `location` с этим значением применяется. Если же ни одно из регулярных выражений не совпало, то применяется конфигурация `location`, запомненного при сравнении по префиксу. Если существует значение директивы `location` с использованием модификатора `=`, то при при первом же полном соответствии запрошенного URI этому значению поиск останавливается.

Самое простое значение директивы `location` - это `/`, что означает конфигурацию для всех URI, указанных для `server_name`.



### Примеры описания сервера ###


#### Сайты со статическим контентом ####

Если сайт имеет статический контент и нет необходимости размещать какие-либо ресурсы за пределами `root`, то директива `location` может либо не понадобиться вовсе, если указать `root` в контексте `server`, либо `location` может иметь самую простую реализацию:

	location / {
        root /usr/share/nginx/html;
		index index.html index.htm;
    }

Здесь директива `index` определяет файлы, которые могут быть использованы как индексные файлы, размещенные по запрашиваемому пути.

Для большей демонстрации работы `location`, можно рассмотреть следующий случай. Пусть имеется статический сайт `example.com` с одним и тем же контентом, но на разных языках - русском и английском. Для каждого языка создан свой отдельный домен: `ru.example.com` - для русскоязычной версии и `en.example.com` - для англоязычной. Для каждого из вариантов сайта создан свой каталог, соответственно:

	/usr/share/nginx/html/example/ru

и

	/usr/share/nginx/html/example/en

Файл конфигурации для каждого сервера будет предельно прост:

	server {
		server_name ru.example.com;
		root   /usr/share/nginx/html/example/ru;
		index index.html index.htm;
	}

	server {
		server_name en.example.com;
		root   /usr/share/nginx/html/example/en;
		index index.html index.htm;
	}


Это нормально, что страницы с текстом на разных языках будут размещаться в своих каталогах. Но ведь стили, скрипты, медиа и другие ресурсы вероятно должны быть общими, если контент одинаковый. Нет смысла дублировать ресурсы в каждом из каталогов, разумнее будет поместить их в общий. Однако, как было сказано выше, выход запроса за `root` не возможен. Здесь и пригодиться директива `location`, которая переопределит `root`, когда на сервер поступает запрос ресурса.

Пусть для рассматриваемого сайта стили запрашиваются по пути `/css`, скрипты - `/js`, медиа - `/images`. При этом физически на сервере созданы одноименные каталоги по пути `/usr/share/nginx/html/example`. Тогда для *каждого* из серверов необходимо прописать соответствующие `location`:

	server {
		server_name ru.example.com;
		root   /usr/share/nginx/html/example/ru;
		index index.html index.htm;

		location /css {
			root /usr/share/nginx/html/example;
		}

		location /js {
			root /usr/share/nginx/html/example;
		}

		location /images {
			root /usr/share/nginx/html/example;
		}
	}

	server {
		server_name en.example.com;
		root   /usr/share/nginx/html/example/en;
		index index.html index.htm;

		location /css {
			root /usr/share/nginx/html/example;
		}

		location /js {
			root /usr/share/nginx/html/example;
		}

		location /images {
			root /usr/share/nginx/html/example;
		}
	}


Чтобы не повторять в настройках каждого сервера одно и тоже, можно повторяемые директивы вынести в отдельный файл и подключать его в нужном месте. Например, создать файл `example_common.conf` с содержимым:

	location /css {
		root /usr/share/nginx/html/example;
	}

	location /js {
		root /usr/share/nginx/html/example;
	}

	location /images {
		root /usr/share/nginx/html/example;
	}

а затем подключать его:

	server {
		server_name ru.example.com;
		root   /usr/share/nginx/html/example/ru;
		index index.html index.htm;
		
		include example_common.conf;
	}

	server {
		server_name en.example.com;
		root   /usr/share/nginx/html/example/en;
		index index.html index.htm;

		include example_common.conf;
	}

Здесь можно обратить внимание на то, что пути `/css`, `/js`, `/images` чисто условны. То есть, размещать в этих каталогах можно все, что угодно и это будет выведено в соответствующем запросе. Но есть способ привязать каталоги к конкретному типу ресурсов. Для этого используются регулярные выражения при указании пути в `location`. Например, указание пути:

	location ~ \.css$ {
		root /usr/share/nginx/html/example/css;
	}

приведет к поиску всех ресурсов `*.css` в каталоге `/usr/share/nginx/html/example/css`. А если стиль расположен в подкаталоге: `ru.example.com/slider/slider.css`, то и размещаться он должен соответственно по пути

	/usr/share/nginx/html/example/css/slider

Подобные настройки для скриптов и изображений могут выглядеть следующим образом:

	location ~ \.js$ {
		root /usr/share/nginx/html/example/js;
	}

	location ~ \.(gif|jpg|jpeg|png)$ {
		root /usr/share/nginx/html/example/images;
	}


Здесь приведены простые примеры для того, чтобы представить, как работает директива `location`. Более подробнее можно почитать в [документации по `location`](http://nginx.org/en/docs/http/ngx_http_core_module.html#location).


#### Динамические сайты ####


В статических сайтах основная задача веб-сервера - отдать запрашиваемый в URL ресурс, который является статическим файлов на сервере. В динамических сайтах некоторые запрашиваемые ресурсы подразумевают исполняемый файл, написанный, например, на каком-либо из интерпретируемых или компилируемых языков программирования. Этот файл должен быть исполнен, а затем сервер возвращает результат выполнения. Сам сервер `nginx` не исполняет скрипты, этим занимаются соответствующие процессы (интерпретаторы, виртуальные машины и т.д.), работающие параллельно. Задача веб-сервера - перенаправить запрашиваемый ресурс на исполнение процессу. Далее рассматривается самый простой пример с PHP.

Как правило, для работы с `nginx` используется `php-fpm`, который является реализацией [FastCGI](http://ru.wikipedia.org/wiki/FastCGI) для PHP. Взаимодействие `nginx` и `php-fpm` может осуществляться как по TCP/IP протоколу, так и через сокет (Unix Socket). Конкретно, как будет работать `php-fmp` указывается в его файле конфигурации, и соответствующим образом должно быть настроено в `nginx`.

Пусть в конфигурации `php-fpm` адресом для FastCGI-запросов является `127.0.0.1:9000` (обычно, значение по умолчанию при установке `php-fpm`). Чтобы перенаправить на выполнение запрашиваемый ресурс, являющийся PHP-скриптом, в `nginx` используется все та же директива `location` с самым простым набором директив:

	location ~ \.php$ {
		fastcgi_pass  127.0.0.1:9000;
		fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
		include       fastcgi_params;
	}

Здесь директивы:

* `fastcgi_pass` - адрес по которому FastCGI-приложение ожидает запрос исполняемого ресурса;
* `fastcgi_param` - устанавливает значение параметра, передаваемого FastCGI. В данном случае устанавливается параметр `SCRIPT_FILENAME` значением `$document_root$fastcgi_script_name`, где в свою очередь:
	* `$document_root` - переменная, содержащая `root` текущего запроса;
	* `$fastcgi_script_name` - имя запрашиваемого ресурса. Если в запросе имя не указано (запрос заканчивается на `/`), то будет подставлено значение, определенное директивой `index`. Так как `index` может определять не только исполняемый ресурс, но и статические страницы - \*.html, \*htm, то для FastCGI можно прописать "свой" индекс в директиве `fastcgi_index`.

Здесь же `include` подключает файл `fastcgi_params` (обычно расположенный рядом с `nginx.conf`), в котором необходимые параметры FastCGI определяются соответствующими значениями сервера `nginx`. Этими параметрами, например, могут быть параметры запроса (`$query_string`), метод запроса (`$request_method`) и многие другие.

В случае, когда `php-fpm` настроен на работу через сокет, директива `fastcgi_pass` будет выглядеть следующим образом:

	fastcgi_pass unix:/var/run/php-fpm/fastcgi.socket;

Тут надо понимать, что путь к сокету `fastcgi.socket` может отличаться.



### Пример итоговой конфигурации ###

После всех поверхностных теоретических выкладок, можно привести пример простой итоговой конфигурации виртуального сервера `nginx`. Конфигурация приводится для обычного динамического сайта, работающего на PHP.

	server {

		server_name info.example.com;
		root /usr/share/nginx/html/info;
		index index.html index.php;

		location ~ \.php$ {
			fastcgi_pass  unix:/var/run/php-fpm/fastcgi.socket;
			fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
			include       fastcgi_params;
		}

	}

